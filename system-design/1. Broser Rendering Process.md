
Broser rendering:
https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work
https://medium.com/@regondaakhil/the-anatomy-of-browser-rendering-how-web-pages-come-to-life-6fa9e801a3f



The browser rendering process is complex and involves several stages, from parsing the HTML and CSS files to painting pixels on the screen. Below is an **in-depth explanation** of the entire rendering pipeline, focusing on each critical step.

### 1. **Parsing HTML to Construct the DOM Tree**
   When the browser receives HTML from the server, it parses the HTML file in a sequential manner to create the **DOM (Document Object Model)**. The DOM is a tree-like structure representing the hierarchical arrangement of the elements (nodes) in the document.

   **Steps in HTML Parsing:**
   - The browser reads the raw HTML markup.
   - Each HTML tag (like `<div>`, `<p>`, `<img>`, etc.) becomes a node in the DOM tree.
   - The browser also handles HTML errors, such as unclosed tags, to ensure the DOM tree is correctly constructed.

   For example:
   ```html
   <div>
     <h1>Hello</h1>
     <p>World</p>
   </div>
   ```
   The DOM tree generated would look like:
   ```
   div
   ├── h1
   └── p
   ```

### 2. **Parsing CSS to Construct the CSSOM**
   Simultaneously, the browser also downloads and parses CSS files linked in the HTML (e.g., through `<link>` or `<style>` tags). This results in the **CSSOM (CSS Object Model)**, a tree-like structure similar to the DOM, but it only represents the style rules.

   **Steps in CSS Parsing:**
   - The browser reads and parses the CSS styles.
   - The CSSOM tree maps the rules and properties to different elements.

   For example:
   ```css
   div {
     color: blue;
   }
   p {
     font-size: 16px;
   }
   ```
   The CSSOM tree would represent how styles are applied:
   ```
   Style Rules:
   div { color: blue; }
   p { font-size: 16px; }
   ```

### 3. **DOM + CSSOM = Render Tree Construction**
   After the DOM and CSSOM trees are created, the browser combines them to build the **Render Tree**. This tree contains only the nodes necessary for rendering the visible part of the document. 

   - Non-visible elements like `<head>` and those with `display: none` are excluded from the render tree.
   - For each visible element, the browser combines its content from the DOM and its style information from the CSSOM.

   For example, for the following HTML and CSS:
   ```html
   <div>
     <h1>Hello</h1>
     <p style="display: none">World</p>
   </div>
   ```
   ```css
   h1 {
     color: red;
   }
   ```
   The render tree would look like this (since the `<p>` tag is hidden):
   ```
   div
   └── h1 (color: red)
   ```

### 4. **Layout (Reflow)**
   Once the render tree is constructed, the browser moves to the **layout** phase, also known as **reflow**. In this stage, the browser calculates the position and size of each node in the render tree.

   **Key Factors in Layout:**
   - Each element’s size is calculated based on its width, height, padding, margins, borders, etc.
   - The browser determines where each element should be positioned on the screen based on the flow of the document and any CSS positioning rules (e.g., `absolute`, `relative`, `float`).

   For example:
   ```html
   <div style="width: 500px;">
     <h1>Hello</h1>
   </div>
   ```
   During layout, the browser calculates that the `<h1>` inside the `<div>` should have a width of 500px and be positioned inside the parent element.

   This layout calculation can be complex for pages with lots of content or responsive layouts. Layout recalculations (reflows) are triggered when content, dimensions, or other layout-affecting properties change (e.g., resizing the window or adding new elements dynamically).

### 5. **Painting**
   After the layout step, the browser moves to the **painting** phase, where it draws the visual elements of the render tree on the screen. This includes:
   - Drawing the text, colors, borders, shadows, images, backgrounds, and any other visual elements.

   The browser works by converting each visual component into pixel-level information that the screen can display. Painting is done in **layers**, which leads into the next step.

### 6. **Layer Creation**
   In modern browsers, complex pages are broken into **layers** for more efficient painting and compositing. Layers are created for certain elements that need special handling, such as:
   - Elements that have 3D transforms, animations, or hardware-accelerated effects.
   - Elements that use `position: fixed` or `position: absolute`.

   These layers allow for smoother transitions and animations, as only parts of the page need to be redrawn (instead of the entire page) when a change occurs.

### 7. **Compositing**
   Once the browser has created and painted all the layers, the final step is **compositing**. In this phase:
   - The browser assembles the different layers, combining them in the correct order to render the final image on the screen.
   - The **GPU** (Graphics Processing Unit) may be involved in this process for efficiency, especially when handling animations or complex visual effects.

   Compositing ensures that all the elements of the page are painted correctly, respecting the stacking order (e.g., which element should appear on top).

### 8. **JavaScript Execution and its Effect on Rendering**
   JavaScript execution can interrupt and affect the rendering process, especially if it modifies the DOM or CSSOM. When JavaScript code runs:
   - It can make changes to the DOM (e.g., adding, removing, or modifying elements) or to CSS (e.g., changing styles dynamically).
   - The browser may need to recompute parts of the rendering pipeline, leading to reflows and repaints.

   **Critical aspects of JavaScript in rendering:**
   - **Reflow**: Changes to layout-affecting properties (like `width`, `height`, `position`) cause the layout to be recalculated, which can impact performance if done frequently.
   - **Repaint**: Changes to visual properties (like color or visibility) that don’t affect the layout but still require the browser to repaint the affected area.
   - **Style recalculation**: If JavaScript modifies styles (directly or by changing classes), the CSSOM and render tree must be updated.

   To optimize performance, browsers often batch these operations and apply them all at once.

### 9. **Optimizing Browser Rendering Performance**
   The browser rendering process can be optimized by following best practices that minimize reflows and repaints:
   - **Avoid Layout Thrashing**: Avoid repeatedly reading and writing layout properties (like `offsetWidth` or `getBoundingClientRect()`) in JavaScript loops, which forces the browser to perform multiple reflows.
   - **Use Efficient CSS**: Avoid deep, complex CSS selectors, and prefer lightweight styles.
   - **Optimize Image Loading**: Use techniques like lazy loading to only load images when they are needed.
   - **Minimize DOM Changes**: Group DOM changes together to reduce reflows.
   - **CSS animations over JavaScript**: Use CSS transitions and animations where possible, as these are typically optimized and GPU-accelerated.

### Summary of the Full Rendering Process:
1. **Parse HTML → DOM Tree**
2. **Parse CSS → CSSOM Tree**
3. **Combine DOM + CSSOM → Render Tree**
4. **Calculate Layout → Reflow**
5. **Paint the Render Tree → Draw Visual Elements**
6. **Create Layers for Complex Elements**
7. **Composite Layers → Final Image on Screen**

Each step plays a critical role in how the browser renders a page, and understanding these steps helps developers optimize the performance and behavior of web applications.
# What triggers reflow:
**Reflow**, also known as **layout**, is the process in which the browser recalculates the position and size of elements in the render tree due to changes that affect the layout of the page. Reflow can be an expensive operation in terms of performance, especially if it happens frequently, because it forces the browser to re-compute the layout of part or all of the page.

Here are the main **factors that trigger reflow**:

### 1. **Resizing the Window**
   - When a browser window is resized, the size and layout of elements may need to adjust, especially if the layout uses relative units like percentages, `vw`, or `vh`. This triggers a reflow as the browser recalculates the dimensions of the elements.

### 2. **Adding or Removing Elements**
   - If elements are added, removed, or moved around in the DOM, the browser needs to recalculate the layout to accommodate these changes. Examples include:
     - Adding or removing a DOM element (e.g., `element.appendChild()`, `element.removeChild()`).
     - Changing the position of elements (e.g., moving elements from one part of the DOM to another).

### 3. **Changing Element Dimensions**
   - Directly modifying the size, position, or box model properties (e.g., width, height, padding, border, margin) of an element will trigger a reflow. For example:
     - Changing an element’s `width`, `height`, `top`, or `left` properties.
     - Modifying `display`, `padding`, or `margin` values.

### 4. **Font Changes**
   - Changing the font style or font size of text can affect the layout, as it may change the size of text boxes or the positioning of surrounding elements. This triggers reflow.

### 5. **Content Changes**
   - If the content within an element changes, such as modifying the text inside a block, the browser needs to reflow to account for the new content's size and the layout shift it may cause.

### 6. **CSS Properties that Affect Layout**
   - Certain CSS properties directly affect the layout and trigger reflow. These include:
     - `width`, `height`, `padding`, `border`, `margin`
     - `display` (e.g., switching from `display: none` to `display: block`)
     - `position` (e.g., switching from `static` to `absolute` or `fixed`)
     - `float`
     - `overflow`

### 7. **Changing the Document Structure**
   - Modifying the DOM’s structure can also trigger reflow, such as:
     - Modifying attributes that affect layout (like changing `class` or `id` that alters the styling).
     - Using methods that change the DOM tree, such as `innerHTML`, `appendChild()`, `removeChild()`, etc.

### 8. **Scrolling**
   - Some changes in scroll position can trigger reflows, especially if the content being scrolled into view requires layout recalculations.

### 9. **CSS Animations or Transitions**
   - Animating properties that affect layout, such as animating the width, height, padding, or margin of an element, will trigger reflow during each step of the animation.

### 10. **Changing Style via JavaScript**
   - Manipulating the CSS styles of elements through JavaScript, especially if it involves layout-affecting properties, will trigger reflow. For example:
     - Using `element.style` to modify layout-affecting properties.
     - Adding or removing CSS classes with JavaScript that modify layout-affecting styles.

### 11. **Getting Layout Information**
   - Reading certain layout properties, such as `offsetHeight`, `offsetWidth`, `scrollTop`, or `getBoundingClientRect()`, will trigger a reflow because the browser needs to calculate the up-to-date layout to return the correct values. This is called a **layout "read" operation** and can force the browser to flush the changes if there are any pending layout calculations.

### Summary of Common Reflow Triggers:
- Resizing the browser window.
- Adding, removing, or changing DOM elements.
- Modifying the size or positioning properties (`width`, `height`, `margin`, etc.).
- Changing font styles or text content.
- Applying or modifying CSS properties that affect layout.
- Running JavaScript that alters the structure or layout of the page.

### Performance Impact of Reflow:
Reflows are costly in terms of performance, especially if they occur frequently or affect a large portion of the document (e.g., reflowing the entire page rather than just a small section). Optimizing how and when reflows happen is crucial to maintaining smooth user experiences, particularly for complex or dynamic web pages.